using System.Collections.Generic;
using Helion.Audio;
using Helion.Audio.Sounds;
using Helion.Geometry.Vectors;
using Helion.Resources.Archives.Collection;
using Helion.Resources.Definitions.SoundInfo;
using Helion.Util;
using Helion.Util.Extensions;
using Helion.Util.RandomGenerators;
using Helion.World.Entities;
using Helion.World.Entities.Players;

namespace Helion.World.Sound;

public class WorldSoundManager : SoundManager, ITickable
{
    private readonly IWorld m_world;

    public WorldSoundManager(IWorld world, IAudioSystem audioSystem, ArchiveCollection archiveCollection) :
        base(audioSystem, archiveCollection)
    {
        m_world = world;
    }

    protected override IRandom GetRandom() => m_world.Random;

    protected override double GetDistance(ISoundSource soundSource)
    {
        return soundSource.GetDistanceFrom(m_world.ListenerEntity);
    }

    public override IAudioSource? PlayStaticSound(string sound)
    {
        ISoundSource soundSource = DefaultSoundSource.Default;
        return m_world.SoundManager.CreateSoundOn(soundSource, sound,
            SoundChannelType.Auto, DataCache.Instance.GetSoundParams(soundSource, attenuation: Attenuation.None));
    }

    public IAudioSource? CreateSoundOn(ISoundSource soundSource, string sound, SoundChannelType channel, SoundParams soundParams)
    {
        if (!soundSource.CanMakeSound())
            return null;

        return CreateSound(soundSource, soundSource.GetSoundPosition(m_world.ListenerEntity), soundSource.GetSoundVelocity(), sound, channel, soundParams);
    }

    protected override int GetPriority(ISoundSource soundSource, SoundInfo soundInfo, SoundParams soundParams)
    {
        // Sounds from the listener are top priority.
        // Sounds that do not attenuate are next, then prioritize sounds by the type the entity is producing.
        if (ReferenceEquals(soundSource, m_world.ListenerEntity))
            return 0;

        if (soundParams.Attenuation == Attenuation.None)
            return 1;

        if (soundSource is Entity entity && !entity.IsPlayer)
        {
            switch (soundParams.SoundType)
            {
                case SoundType.Pain:
                    return 3;
                case SoundType.See:
                    return 4;
                case SoundType.Active:
                    return 5;
                default:
                    break;
            }
        }

        return 2;
    }

    protected override SoundInfo? GetSoundInfo(ISoundSource? source, string sound)
    {
        if (source is Player player)
        {
            string playerSound = SoundInfoDefinition.GetPlayerSound(player.Info.GetGender(), sound);
            SoundInfo? soundInfo = ArchiveCollection.Definitions.SoundInfo.Lookup(playerSound, m_world.Random);
            if (soundInfo != null && ArchiveCollection.Entries.FindByName(playerSound) != null)
                return soundInfo;

            // Sound likely does not exist for user selected gender - fallback to default
            playerSound = SoundInfoDefinition.GetPlayerSound("male", sound);
            soundInfo = ArchiveCollection.Definitions.SoundInfo.Lookup(playerSound, m_world.Random);
            if (soundInfo != null)
                return soundInfo;

        }

        return base.GetSoundInfo(source, sound);
    }

    protected override void AttenuateIfNeeded(ISoundSource source, SoundInfo info, SoundParams soundParams)
    {
        // Don't attenuate sounds generated by the listener, otherwise movement can cause the sound to be off
        if (ReferenceEquals(source, m_world.ListenerEntity))
            soundParams.Attenuation = Attenuation.None;
    }

    public override void Update()
    {
        Tick();
    }

    public void Tick()
    {
        AudioManager.SetListener(m_world.ListenerPosition, m_world.ListenerAngle, m_world.ListenerPitch);
        UpdateWaitingLoopSounds();
        PlaySounds();

        if (PlayingSounds.Empty())
            return;

        LinkedListNode<IAudioSource>? node = PlayingSounds.First;
        LinkedListNode<IAudioSource>? nextNode;
        while (node != null)
        {
            nextNode = node.Next;
            if (node.Value.IsFinished())
            {
                DataCache.Instance.FreeAudioSource(node.Value);
                PlayingSounds.Remove(node.Value);
            }
            else
            {
                double distance = node.Value.AudioData.SoundSource.GetDistanceFrom(m_world.ListenerEntity);
                if (!CheckDistance(distance, node.Value.AudioData.Attenuation))
                {
                    node.Value.Stop();
                    PlayingSounds.Remove(node);

                    if (ShouldDisposeBumpedSound(node.Value))
                        DataCache.Instance.FreeAudioSource(node.Value);
                }
                else
                {
                    Vec3D? position = node.Value.AudioData.SoundSource.GetSoundPosition(m_world.ListenerEntity);
                    if (position != null)
                        node.Value.SetPosition(position.Value.Float);
                }
            }

            node = nextNode;
        }
    }
}
